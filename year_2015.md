# Notes for solving 2015
## Day 01

```
Year2015::Day01
  Part 1
    gives a final result
  Part 2
    gives a final result
  Results
    correctly answers part 1
    correctly answers part 2
```

Ruby's `String` class is very well-furnished, even without all of Rail's `ActiveSupport` goodness. In that case, just using [`#count()`](https://apidock.com/ruby/String/count) is enough to get us out of trouble quickly.

I am pretty sure there must be an algorithm that doesn't include iterating through the whole string, but so far, the only idea I got would be to use bisecting until I get to the proper index, which just felt like a hassle.

## Day 02

```
Year2015::Day02
  Part 1
    gives a final result
  Part 2
    gives a final result
  Results
    correctly answers part 1
    correctly answers part 2
```

I..am not even sure this one was complicated in any way.

## Day 03

```
Year2015::Day03
  Part 1
    gives a final result
  Part 2
    gives a final result
  Results
    correctly answers part 1
    correctly answers part 2
```

The only thing to be wary of is on line 16: without the call to `#dup`, all of Santa's and Robo-Santa's positions will be overwritten, since Ruby's object model has a tendancy to pass references when you expect to pass values.

Passing by value or reference is a really wonky subject, but this [blog post](https://robertheaton.com/2014/07/22/is-ruby-pass-by-reference-or-pass-by-value/) got nice examples that will get you started.

## Day 04

```
Year2015::Day04
  Part 1
    finds winning numbers
    calculates points
    gives a final result
  Part 2
    distributes cards
    gives a final result
  Results
    correctly answers part 1
    correctly answers part 2
```

Part one is pretty easy. One useful method is the [`#&`](https://ruby-doc.org/core-3.0.1/Array.html#method-i-26) operator that takes two arrays and returns a new one with only the matching contents. The syntax is clearly inspired by [bit masking](https://en.wikipedia.org/wiki/Mask_(computing)), which is a subject you should look into if you've never heard of it.

Part two is a bit more annoying and requires to do a two-pass, but nothing really improbable.

## Day 05

```
Year2015::Day05
  Part 1
    finds nice lines
    finds naughty lines
  Part 2
    finds nice lines
    finds naughty lines
  Results
    correctly answers part 1
    correctly answers part 2
```

Again, [Regexp](https://ruby-doc.org/core-2.5.1/Regexp.html) really are one of the best tools in your developer arsenal. In this specific exercise, we can look for repetition by using `\1`, which will reference a previously-captured group. Nothing specifically hard beyond that.

## Day 06

```
Year2015::Day06
  Part 1
    gives a final result
  Part 2
    gives a final result
  Results
    correctly answers part 1
    correctly answers part 2
```

This one actually gave me SOME trouble. My first solution was iterating on each element one by one and was clearly too long. Thanksfully, Ruby is really smart when it comes to replacing slices of an array.

There is an even more beautiful solution for part 2 that consist of only tracking the total numbers of flicks on/off/toggle, but in the off chance that a light already off is turned off again, the results would become false.

Also of note: remember what was discussed earlier about references? Well, the [documentation covers that too](https://ruby-doc.org/core-3.0.1/Array.html#class-Array-label-Creating+Arrays). Quote:

> Note that the second argument populates the array with references to the same object. Therefore, it is only recommended in cases when you need to instantiate arrays with natively immutable objects such as Symbols, numbers, true or false.
>
> To create an array with separate objects a block can be passed instead. This method is safe to use with mutable objects such as hashes, strings or other arrays:

## Day 07

```
Year2015::Day07
  Part 1
    assigns values to wires
  Results
    correctly answers part 1
    correctly answers part 2
```

We already discovered bitwise operators in the previous exercises, so that shouldn't be too hard. The complication comes from building the wires.

The naive implementation, that works very well with the sample input, consists of interpreting each line one by one, storing the value of each wire every time. Unfortunately, not all inputs are indicated in a linear way.

The answer lies in to store all wires, setting up operations with [lazy evaluation](https://betterprogramming.pub/how-lazy-evaluation-works-in-ruby-a90237e99ac3), and letting intepretation work itself all the way back.

## Day 08

```
Year2015::Day08
  Part 1
    calculates data length of code
    calculates data length in memory
    gives a final result
  Part 2
    calculates data length of dump
    gives a final result
  Results
    correctly answers part 1
    correctly answers part 2
```

Understanding how characters escaping works is a massive PAIN, and misunderstand the concept is a reason why [PHP MySQL injections](https://www.php.net/manual/en/security.database.sql-injection.php) were so infamous. Things get even more hairy when you have to work with MULTIPLE type of injections (paths, web, sql,...), or even multiple types of string that don't escape the same way,

In that case, we are lucky, since Ruby already implements [dump](https://ruby-doc.org/3.2.2/String.html#method-i-dump) and [undump](https://ruby-doc.org/3.2.2/String.html#method-i-undump), which happens to work exactly as the exercise require. But since we're here to learn, the methods will alternate at runtime between the Ruby methods and the manual implementation.
 