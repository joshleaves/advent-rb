# Notes for solving 2015
## Day 01

```
Year2015::Day01
  Part 1
    gives a final result
  Part 2
    gives a final result
  Results
    correctly answers part 1
    correctly answers part 2
```

Ruby's `String` class is very well-furnished, even without all of Rail's `ActiveSupport` goodness. In that case, just using [`#count()`](https://apidock.com/ruby/String/count) is enough to get us out of trouble quickly.

I am pretty sure there must be an algorithm that doesn't include iterating through the whole string, but so far, the only idea I got would be to use bisecting until I get to the proper index, which just felt like a hassle.

## Day 02

```
Year2015::Day02
  Part 1
    gives a final result
  Part 2
    gives a final result
  Results
    correctly answers part 1
    correctly answers part 2
```

I..am not even sure this one was complicated in any way.

## Day 03

```
Year2015::Day03
  Part 1
    gives a final result
  Part 2
    gives a final result
  Results
    correctly answers part 1
    correctly answers part 2
```

The only thing to be wary of is on line 16: without the call to `#dup`, all of Santa's and Robo-Santa's positions will be overwritten, since Ruby's object model has a tendancy to pass references when you expect to pass values.

Passing by value or reference is a really wonky subject, but this [blog post](https://robertheaton.com/2014/07/22/is-ruby-pass-by-reference-or-pass-by-value/) got nice examples that will get you started.

## Day 04

```
Year2015::Day04
  Part 1
    finds winning numbers
    calculates points
    gives a final result
  Part 2
    distributes cards
    gives a final result
  Results
    correctly answers part 1
    correctly answers part 2
```

Part one is pretty easy. One useful method is the [`#&`](https://ruby-doc.org/core-3.0.1/Array.html#method-i-26) operator that takes two arrays and returns a new one with only the matching contents. The syntax is clearly inspired by [bit masking](https://en.wikipedia.org/wiki/Mask_(computing)), which is a subject you should look into if you've never heard of it.

Part two is a bit more annoying and requires to do a two-pass, but nothing really improbable.

## Day 05

```
Year2015::Day05
  Part 1
    finds nice lines
    finds naughty lines
  Part 2
    finds nice lines
    finds naughty lines
  Results
    correctly answers part 1
    correctly answers part 2
```

Again, [Regexp](https://ruby-doc.org/core-2.5.1/Regexp.html) really are one of the best tools in your developer arsenal. In this specific exercise, we can look for repetition by using `\1`, which will reference a previously-captured group. Nothing specifically hard beyond that.

## Day 06

```
Year2015::Day06
  Part 1
    gives a final result
  Part 2
    gives a final result
  Results
    correctly answers part 1
    correctly answers part 2
```

This one actually gave me SOME trouble. My first solution was iterating on each element one by one and was clearly too long. Thanksfully, Ruby is really smart when it comes to replacing slices of an array.

There is an even more beautiful solution for part 2 that consist of only tracking the total numbers of flicks on/off/toggle, but in the off chance that a light already off is turned off again, the results would become false.

Also of note: remember what was discussed earlier about references? Well, the [documentation covers that too](https://ruby-doc.org/core-3.0.1/Array.html#class-Array-label-Creating+Arrays). Quote:

> Note that the second argument populates the array with references to the same object. Therefore, it is only recommended in cases when you need to instantiate arrays with natively immutable objects such as Symbols, numbers, true or false.
>
> To create an array with separate objects a block can be passed instead. This method is safe to use with mutable objects such as hashes, strings or other arrays:

## Day 07

```
Year2015::Day07
  Part 1
    assigns values to wires
  Results
    correctly answers part 1
    correctly answers part 2
```

We already discovered bitwise operators in the previous exercises, so that shouldn't be too hard. The complication comes from building the wires.

The naive implementation, that works very well with the sample input, consists of interpreting each line one by one, storing the value of each wire every time. Unfortunately, not all inputs are indicated in a linear way.

The answer lies in to store all wires, setting up operations with [lazy evaluation](https://betterprogramming.pub/how-lazy-evaluation-works-in-ruby-a90237e99ac3), and letting intepretation work itself all the way back.

## Day 08

```
Year2015::Day08
  Part 1
    calculates data length of code
    calculates data length in memory
    gives a final result
  Part 2
    calculates data length of dump
    gives a final result
  Results
    correctly answers part 1
    correctly answers part 2
```

Understanding how characters escaping works is a massive PAIN, and misunderstand the concept is a reason why [PHP MySQL injections](https://www.php.net/manual/en/security.database.sql-injection.php) were so infamous. Things get even more hairy when you have to work with MULTIPLE type of injections (paths, web, sql,...), or even multiple types of string that don't escape the same way,

In that case, we are lucky, since Ruby already implements [dump](https://ruby-doc.org/3.2.2/String.html#method-i-dump) and [undump](https://ruby-doc.org/3.2.2/String.html#method-i-undump), which happens to work exactly as the exercise require. But since we're here to learn, the methods will alternate at runtime between the Ruby methods and the manual implementation.

## Day 09

```
Year2015::Day09
  Part 1
    gives a final result
  Part 2
    gives a final result
  Results
    correctly answers part 1
    correctly answers part 2
```

Any programming school worth its salt will one day ask of you the shortest path between many points. Often, the idea is that you'll use graph theory and implement [Dijkstra's algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm). Sometimes, the school wants your brain for dinner and you'll be asked to further solve the [Travelling Salesman Problem](https://en.wikipedia.org/wiki/Travelling_salesman_problem). Both are very interested concepts in themselves, and a good first approach to [PathFinding](https://en.wikipedia.org/wiki/Pathfinding).

If you're not fond of graph transversal, the best answer is often to start using the [A* (A-Star)](https://en.wikipedia.org/wiki/A*_search_algorithm) algorithm to iterate through all possible paths.

You can then optimize it, for instance instructing the algorithm to stop searching once it's on a path longer than a previously explored one.

As for finding the "longest path"...just imagine you're not looking for a "shortest" or "longest" path, but a "best" path, and change how that path is selected among others.

## Day 10

```
Year2015::Day10
  Part 1
    iterates each look-and-say
  Results
    correctly answers part 1
    correctly answers part 2
```

This exercise is based on John H. Conway's [Look-and-say sequences](https://en.wikipedia.org/wiki/Look-and-say_sequence), you probably know him for the [Game of Life](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life), but the mathematician provided us with lot of science.

Nothing really hard in this exercise, except complexity quickly running high, it becomes important to use the best algorithm to generate the next sequence.

## Day 11

```
Year2015::Day11
  Part 1
    checks first criteria (three straight letters)
    checks second criteria (no i/o/l)
    checks third criteria (two different pairs)
    gives a final result
  Results
    correctly answers part 1
    correctly answers part 2
```

Another exercise that is actually quite simple when you don't have to account for PERFORMANCE: the complexity in this exercise can quickly become huge and it's important that each of your iterations is as fast as you can. A good tool for that is [using Ruby's built-in Benchmark class](https://blog.appsignal.com/2018/02/27/benchmarking-ruby-code.html) to compare which of two implementations is the fastest.

Another thing to do is to use heuristics and pre-sanitization: in this exercise, you don't need to iterate and test from `iaaaaaaa` to `izzzzzzz`.

## Day 12

```
Year2015::Day12
  Part 1
    counts the value of the JSON data
  Part 2
    counts the value of the JSON data
  Results
    correctly answers part 1
    correctly answers part 2
```

That day looked so easy that I could not believe my eyes when I solved it in a simple one-liner: `3.0.0 :001 > pbpaste.scan(/-?\d+/).map(&:to_i).inject(&:+)`.

The second part is a bit more convoluted, but navigating JSON nodes isn't really a pain, you either have a Hash (explore), an Array (explore), or a value (return). Nothing too hard so far.

## Day 13

```
Year2015::Day13
  when Part 1
    gives a final result
  when Results
    correctly answers part 1
    correctly answers part 2
```

Again, refer to [Day 09][##day-09] because we are in a similar configuration, with the exception that we must rejoin our starting point at the end. Nothing too complicated.

Second part is just adding another node with a 0 relationship to all nodes. Surprisingly, it seems our presence lowered the general happiness...

## Day 14

```
Year2015::Day14
  when Part 1
    gives a final result
  when Part 2
    gives a final result
  when Results
    correctly answers part 1
    correctly answers part 2
```

This day doesn't have complicated concepts. If you want to dig, you can think of each reindeer as a [finite-state machine](https://en.wikipedia.org/wiki/Finite-state_machine), which is [one of the concepts that are best solved thanks to Object-oriented programming](https://eev.ee/blog/2013/03/03/the-controller-pattern-is-awful-and-other-oo-heresy/).
