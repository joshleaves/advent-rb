# Notes for solving 2016
## Day 01: No Time for a Taxicab

```
Year2015::Day01
  when Part 1
    gives a final result
  when Part 2
    gives a final result
  when Results
    correctly answers part 1
    correctly answers part 2
```

There really is nothing specifically hard here, it's all about knowing when to properly break out of a loop.

## Day 02: Bathroom Security

```
Year2016::Day02
  when Part 1
    gives a final result
  when Part 2
    gives a final result
  when Results
    correctly answers part 1
    correctly answers part 2
```

While reviewing [another code solution for the previous day's exercise](https://github.com/rHermes/adventofcode/blob/master/2016/01/y2016_d01_p02.py), I was intrigued by a very interesting piece of code: the author had treated the turning of left and right into transition paths from one state to another. While the situation felt like overkill to me in that case, it proved to work perfectly for today's exercise.

## Day 03: Squares With Three Sides

```
Year2016::Day03
  when Part 1
    gives a final result
  when Results
    correctly answers part 1
    correctly answers part 2
```

Navigating a matrix of arrays vertically is a bit strange, but nothing we cannot handle.

## Day 04: Security Through Obscurity

```
Year2016::Day04
  when Part 1
    gives a final result
  when Results
    correctly answers part 1
    correctly answers part 2
```

The second part of this exercise involves implementing a [Caesar cipher](https://en.wikipedia.org/wiki/Caesar_cipher), which is not a hard concept to grasp. It's a bit annoying to work through ASCII values of characters and modulo properly to get the right number.

## Day 05: How About a Nice Game of Chess?

```
Year2016::Day05
  when Part 1
    gives a final result
  when Part 2
    gives a final result
  when Results
    correctly answers part 1
    correctly answers part 2
```

Not gonna lie, brute-forcing [MD5 hashes](https://en.wikipedia.org/wiki/MD5) is not something interesting.

## Day 06: Signals and Noise

```
Year2016::Day06
  when Part 1
    gives a final result
  when Part 2
    gives a final result
  when Results
    correctly answers part 1
    correctly answers part 2
```

Navigating arrays vertically is not hard, just unintuitive.

## Day 07: Internet Protocol Version 7

```
Year2016::Day07
  when Part 1
    can detect IPv7 addresses that support TLS
    gives a final result
  when Part 2
    can detect IPv7 addresses that support SSL
    gives a final result
  when Results
    correctly answers part 1
    correctly answers part 2
```

Again, `Enumerable` to the rescue. The method [`#each_cons`](https://ruby-doc.org/core-3.0.1/Enumerable.html#method-i-each_cons) is perfect for the kind fo look-ahead we require here.

## Day 08: Two-Factor Authentication

```
Year2016::Day08
  when Part 1
    gives a final result
  when Results
    correctly answers part 1
```

This time, `Array` saves us with [`#rotate`](https://ruby-doc.org/core-3.0.1/Array.html#method-i-rotate). Be careful: the rotation is from beginning to end, so the LAST element becomes first for every rotation, which isn't the most intuitive way to do this (first element becomes second feels more intuitive, no?).

Second part will have to be read on your own.

## Day 09: Explosives in Cyberspace

```
Year2016::Day09
  when Part 1
    expands a string
    gives a final result
  when Part 2
    gives a final result
  when Results
    correctly answers part 1
    correctly answers part 2
```

Recursion, it's always about recursion.
